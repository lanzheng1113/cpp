template<typename T,typename V>
bool AVLTree<T,V>::deleteByCopying(AVLNode<T,V>*&p,const T& e) {
	  AVLNode<T,V>* tmp = p;
      if(p == 0) {
    	  return false; //删除失败
      }
      if(e == p->key) {  //删除节点
    	   if(p->left == 0) {
    		    p = p->right;
    		    delete tmp;
    	   }else if(p->right == 0) {
    		   p = p->left;
    		   delete tmp;
    	   }else {
                  AVLNode<T,V> *leftMax = p->left;
                  while(leftMax->right != 0) {
                	    leftMax = leftMax->right;
                  }
                  p->key = leftMax->key;
                  p->value = leftMax->value;
                  /*
                   * 注意,这里不立即修改指针和删除leftMax节点
                   * 而是让递归继续，在p的左子树上继续删除e
                   * 这样做的好处就是不用我们手动的从previous节点到p节点来调整许多不平衡点
                   * 而是在函数递归返回的时候，让其统一调整
                   *  初始 previous = p
                   *
                  if(previous == p) {
                	    p->left = leftMax->left;
                  }else {
                	   previous->right = leftMax->left;
                  }
                  delete leftMax;
                  */
                  deleteByCopying(p->left,leftMax->key); // 再次调用该函数，删除leftMax节点
    	   }
      }else if (e < p->key) {
    	     bool ret = deleteByCopying(p->left,e); // 尝试从左边删除
    	     if(!ret) return false; // 如果删除失败，则不进行任何调整
    	     p->height = std::max( getHeight(p->left),getHeight(p->right))+1;//更新高度
             if(getHeight(p->right)-getHeight(p->left) == 2) {
            	   if(getHeight(p->right->left) > getHeight(p->right->right) ) {  // RL
            		       rightRotate(p->right);
            		       leftRotate(p);
            	   }else {  // RR
            		   rightRotate(p);
            	   }
             }
      }else if(e > p->key) {
    	  bool ret = deleteByCopying(p->right,e);// 尝试从右边删除
    	  if(!ret)  return false; // 如果删除失败，则不进行任何调整
    	  p->height = std::max( getHeight(p->left),getHeight(p->right))+1;//更新高度
          if(getHeight(p->left)-getHeight(p->right) == 2) {
        	         if(getHeight(p->left->left) > getHeight(p->left->right) ){   // LL
        	        	     rightRotate(p);
        	         }else {  // LR
        	        	     leftRotate(p->left);
        	        	     rightRotate(p);
        	         }
          }
      }
      return true;
}