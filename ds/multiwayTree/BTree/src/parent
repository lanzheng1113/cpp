    34		  	for(int j = p->keynum-1; j >= index;j--)
    35		  		  p->keys[j+1] = p->keys[j];
    36		  	p->keys[index] = e;
    37		    p->keynum++;
    40		 while(p->keynum > MAX_KEY_NUM) {
    41			 	 k = p->keys[p->keynum / 2]; // 获取中间值
    45			     BTreeNode<T,M> * parent = p->parent;
    48	            	     root->ptr[0] = node1;
    49	            	     node1->parent = root;
    50	            	     root->ptr[1] = node2;
    51	            	     node2->parent = root;
    56	            	     for( i = 0; i < parent->keynum && parent->keys[i] < k;++i);
    58	            	 	for(int j = parent->keynum-1; j >= i;j--) {
    59	            	 		parent->keys[j+1] = parent->keys[j];
    60	            	 		parent->ptr[j+2] = parent->ptr[j+1];
    62	            	 	parent->keys[i] = k;
    63	            	 	parent->ptr[i+1] = node2;
    64	            	 	node2->parent = parent;
    65	            	 	parent->keynum++;
    79				for(index=0;index < pcur->keynum && pcur->keys[index] < e;++index);
    81				if(index == pcur->keynum || pcur->keys[index] > e) {
    83						pcur = pcur->ptr[index]; // 继续在下层查找
    97		int mid = p->keynum / 2;
   101	   for(int i = mid+1; i < p->keynum;i++) {
   102		     node2->keys[node2->keynum] = p->keys[i];
   103		     if(p->ptr[i] != 0)
   104		    	 p->ptr[i]->parent = node2;		//注意重新设置父节点指向
   105		     node2->ptr[node2->keynum] = p->ptr[i];
   106		     node2->keynum++;
   108	   node2->ptr[node2->keynum] = p->ptr[p->keynum];
   109	   if(p->ptr[p->keynum] != 0)
   110		   p->ptr[p->keynum]->parent = node2;
   112	   node1->keynum = mid;
   129		    for(;index < p->keynum && p->keys[index] < e;index++); // 键e在p中的索引
   130	        if(p->ptr[0] != 0) {   // 非叶子节点删除
   132	        	  BTreeNode<T,M>* q = p->ptr[index];
   133	              while(q->ptr[q->keynum] != 0)
   134	            	        q = q->ptr[q->keynum];
   135	              T preMax = q->keys[q->keynum-1];
   136	              p->keys[index] = preMax;
   140	        	for(int i= index+1;i < p->keynum;i++)
   141	        		  p->keys[i-1] = p->keys[i];
   142	            p->keynum--;
   143	            while(p->parent != 0 && p->keynum < MIN_KEY_NUM) {  // 删除后键数目下溢
   144	            	    BTreeNode<T,M>* left,*right,*parent = p->parent;
   149	            		}else if (parent->parent == 0){		// 父节点是根节点
   150	                            if(parent->keynum == 1) {
   153	                            	root->parent = 0;
   172	    for(;index < parent->keynum && parent->keys[index] < left->keys[left->keynum-1] ;++index); // 找出parent中划分left,right的中间值
   173	    if(left->keynum < right->keynum) {											// right向left输送
   174	    	    left->keys[left->keynum] =  parent->keys[index]; 				// 将划分left,right的中间值放到left中
   175	    	    left->keynum++;
   176	    	    parent->keys[index] = right->keys[0]; 						// 将right中第一个值复制到父节点中
   177	    	    left->ptr[left->keynum] = right->ptr[0];
   178	    	    if(right->ptr[0] != 0) right->ptr[0]->parent = left;
   179	    	    for(int j=1;j < right->keynum;j++) {							// 移动right中元素，重新排列
   180	    	    	 right->keys[j-1] = right->keys[j];
   181	    	    	 right->ptr[j-1] = right->ptr[j];
   183	    	    right->ptr[right->keynum-1] = right->ptr[right->keynum];
   184	    	    right->keynum--;
   186	           for(int j=0;j< right->keynum;++j) {
   187	        	     right->keys[j+1] = right->keys[j];
   188	        	     right->ptr[j+2] = right->ptr[j+1];
   190	           right->ptr[1] = right->ptr[0];
   191	           right->keys[0] = parent->keys[index];
   192	           right->ptr[0] = left->ptr[left->keynum];
   193	           if(right->ptr[0] != 0) right->ptr[0]->parent = right;
   194	           right->keynum++;
   195	           T tmp = left->keys[left->keynum-1];
   196	           parent->keys[index] = tmp;
   197	           left->keynum--;
   206			for(;index < parent->keynum && parent->keys[index] < left->keys[left->keynum-1] ;++index); // 找出parent中划分left,right的中间值
   207			 left->keys[left->keynum] =  parent->keys[index]; // 将划分left,right的中间值放到left中
   208			 left->keynum++;
   209			for(int j=0;j < right->keynum;j++) {
   210				left->keys[left->keynum] = right->keys[j]; // 移动right中元素到left节点
   211				left->ptr[left->keynum] = right->ptr[j];	// 注意指针也要移动过来
   212				if(right->ptr[j] != 0)  right->ptr[j]->parent = left;
   213				left->keynum++;
   215		   left->ptr[left->keynum] = right->ptr[right->keynum];
   216		   if(right->ptr[right->keynum] != 0)  right->ptr[right->keynum]->parent = left;
   218		   parent->ptr[index+1] = 0;
   221		  for(int j=index+1;j < parent->keynum;++j) {
   222			      parent->keys[j-1] = parent->keys[j];
   223			      parent->ptr[j] = parent->ptr[j+1];
   225		  parent->keynum--;
   235		BTreeNode<T,M>* parent = p->parent;
   238		for(;i < parent->keynum+1 && parent->ptr[i] != p ;i++);  // 获取p在父节点中索引
   239		if( i == parent->keynum) {				// 最后一个孩子
   240			left = parent->ptr[parent->keynum-1];
   243			 right = parent->ptr[1];
   245			right = parent->ptr[i+1];
   246			if(parent->ptr[i+1]->keynum > MIN_KEY_NUM)
   247				right = parent->ptr[i+1];
   248			else if(parent->ptr[i-1] ->keynum > MIN_KEY_NUM) {
   249				left = parent->ptr[i-1];
   253	    return left->keynum > MIN_KEY_NUM || right->keynum >MIN_KEY_NUM ;
   269		for(; i < p->keynum ;++i)
   270			  if(p->keys[i] >= e)
   272		if(i == p->keynum || p->keys[i] > e)
   273			return search(p->ptr[i],e); // 继续在子节点上查找
   280			   for(int i= 0;i < p->keynum;++i)
   281				   clear(p->ptr[i]);						// 清除子节点
   282			   if(p->keynum > 0)
   283				   clear(p->ptr[p->keynum]); // 清除最后一个指针
   291			  for(int i=0;i < p->keynum;++i) {
   292				  traverse(p->ptr[i]);					// 先访问比键小的节点
   293	              std::cout<<p->keys[i]<<"\t";				// 访问这个键
   295			  traverse(p->ptr[ p->keynum]); // 访问比最后一个大的节点
   308			for(int i=0;i< p->keynum;i++) {
   309				std::cout<<p->keys[i]<<" ";
   310				if(p->ptr[i] != 0)
   311						queue.push(p->ptr[i]);
   314		    if(p->ptr[p->keynum] != 0)
   315		    	queue.push( p->ptr[p->keynum] );
